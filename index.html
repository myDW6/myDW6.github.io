<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>17年在雾都的博客</title>
  <meta name="author" content="dw Shao">

  
  

  <link rel="alternate" href="/atom.xml" title="17年在雾都的博客" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
  
</head>

<body>
  <header id="header" class="inner"><nav>
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav></header>
  <div id="content" class="inner">
  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/12/09/csapp第七章(1)/">csapp第七章 链接(1)</a></h1>
  

    <time datetime="2018-12-09T09:43:30.761Z">
  <span class="day">9</span><span class="month">Dec</span>
</time>
  </header>
  <div class="entry-content">
    
      <h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>​    将各种代码和数据收集和组合成为一个单一文件的过程</p>
<p>链接的好处是：分离编译  我们可以不用把应用程序组织为一个巨大的源文件，而是将它分解成更小，更好管理的模块，独立修改和编译</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>为了构成可执行文件：链接器必须完成：符号解析 重定位两个任务</p>
<p>符号解析：目标文件定义和引用符号。</p>
<p>​    每个符号可以对应c语言中的函数，全局变量，静态变量。符号解析的作用就是将这些符号引用和符号定义关联起来</p>
<p>重定位：通过之前的学习了解到：我们的代码和数据会存储在以0地址开始的区域，但                      是多个可重定位的文件都是以这样的方式，我们怎么样将他们组合呢？</p>
<p>链接器可以通过把每个符号与一个内存关联，从而实现重定位</p>
<h4 id="目标文件"><a href="#目标文件" class="headerlink" title="目标文件"></a>目标文件</h4><p>​    1可重定位目标文件：    包含二进制代码和数据，与其他可重定位目标文件合并成可执行文件</p>
<p>​    2可执行目标文件：        包含二进制代码和数据，可以直接被复制到内存中执行</p>
<p>​    3共享目标文件    ：        一种特殊的可重定位目标文件  可以在程序加载运行时被动态加载入内存</p>
<p>我们熟悉的编译 汇编 链接过程中，前两个过程会生成可重定向目标文件（包括3）链接器会生成可执行目标文件</p>
<p>解释下目标文件的意思：一个以特定文件格式的形式存放在硬盘上的一个字节序列（目标模块）a.out   a.exe  等等</p>
<p>​    </p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>

  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/12/02/csapp第六章存储器层次结构/">csapp第六章 存储器层次结构</a></h1>
  

    <time datetime="2018-12-02T08:38:20.615Z">
  <span class="day">2</span><span class="month">Dec</span>
</time>
  </header>
  <div class="entry-content">
    
      <p> 第六章总的来看比较简单，科普性的介绍了计算机系统里的存储层次结构，如下图所示</p>
<p><img src="https://res.cloudinary.com/shmily/image/upload/v1543739016/%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E5%9B%BE.jpg" alt="存储器层次图"></p>
<p>由上至下，存储设备速度越来越慢，但相应的容量越来越大，价格也越来越便宜</p>
<p>最上层的像高速缓冲存储器会使用有双稳态的SRAM，而我们熟悉的主存会采用以电容和访问晶体管构成的DRAM</p>
<p>理解程序的局部性原理：</p>
<p>​    时间局部性：</p>
<p>​        在一个具有良好局部性的程序中，被引用过一次的程序位置很可能在不远的将来被多次引用</p>
<p>​    空间局部性:</p>
<p>​        在一个具有良好空间局部性的程序中，如果一个内存位置被引用了一次，那么很可能在不远的将来引用附近的一个内存位置</p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>

  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/11/18/csapp第三章程序的机器级表示（3）/">csapp第三章 程序的机器级表示（3）</a></h1>
  

    <time datetime="2018-11-18T08:03:18.372Z">
  <span class="day">18</span><span class="month">Nov</span>
</time>
  </header>
  <div class="entry-content">
    
      <h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​    第三章总的来说，可以说是简要的说明了汇编语言的一些细节</p>
<p>之前学校有开设汇编语言的课程，只是那时的自己还处在懵逼的时代，感觉这种底层的知识离我很遥远，但是当我渐渐改变，迷迷糊糊的看完csapp第三章后，也能得到一些感慨：    那就随便说说吧！</p>
<h4 id="感慨"><a href="#感慨" class="headerlink" title="感慨"></a>感慨</h4><p>先看一个c语言代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int sum(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int t=x+y;</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl (%ebp),%eax  从内存中得到x放入eax寄存器</span><br><span class="line">movl 4(%ebp),%edx  从内存中得到y  放入edx寄存器</span><br><span class="line">addl %edx,%eax       将x和y相加</span><br></pre></td></tr></table></figure>
<p>以IA32来说明：    </p>
<p>​    mov 是移动，将%ebp 移动到%eax 后面的l是区分不同的数据类型的  char int double 这些类型，l就是为了区别它们     这个指令将一个地址里面的数移动到另一个地方，也就想当于赋值  。</p>
<p>想想：我们将一个短数据放入长数据位置会怎么样？</p>
<p>一个char放入一个int的空间，会剩下8位空的，那么需要使用movsbl（符号拓展）和movzbl（0拓展）这两个指令  c语言中的有符号无符号之间的运算，便需要借助这些指令。</p>
<h6 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h6><p>c语言具有不同的数据类型，汇编也一样：</p>
<p>​    立即数类型, 也就是常数，在程序中我们会常常用到常数，在ATT表示下是一个常数前面加上$。</p>
<p>​    寄存器类型，CPU中，有一个寄存器文件，寄存器类型就是指寄存器文件中某个寄存器中的内容。</p>
<p>​    存储器引用，存储器指我们的内存区，内存相当于一个大型的字节数组，这里的存储器引用就是指这个数组的索引(数组的下标)</p>
<h5 id="常见指令"><a href="#常见指令" class="headerlink" title="常见指令"></a>常见指令</h5><p>书中讲解的比较详细；这里挑一个出来说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int choose(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(x&lt;y)</span><br><span class="line">        return y-x;</span><br><span class="line">    else</span><br><span class="line">        return x-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">movl 8(%ebp),%edx   x在%ebp+8处</span><br><span class="line">movl 12(%ebp),%eax  y在%ebp+12处</span><br><span class="line">cmpl %eax,%edx</span><br><span class="line">jge  .L2</span><br><span class="line">subl %edx,%eax</span><br><span class="line">jmp .L3</span><br><span class="line">.L2:</span><br><span class="line">subl %eax,%edx</span><br><span class="line">movl %edx,%eax</span><br><span class="line">.L3:</span><br></pre></td></tr></table></figure>
<p>第三条指令就是比较指令，    可以发现：每条比较指令下面跟着一条跳转语句，执行完比较操作后，相应的标志位会置位。</p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>

  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/11/11/csapp第三章程序的机器级表示（2）/">csapp第三章 程序的机器级表示（2）</a></h1>
  

    <time datetime="2018-11-11T09:13:50.993Z">
  <span class="day">11</span><span class="month">Nov</span>
</time>
  </header>
  <div class="entry-content">
    
      <p>### </p>
<p>本周总结下一个问题以及一些想法：</p>
<p>​    Q：在汇编层面上，只有几个简单的指令：</p>
<p>​            数据传输：数据从内存到寄存器，寄存器到内存</p>
<p>​            算逻运算</p>
<p>​            比较 和 跳转</p>
<p>​        那么，这么几个简单的指令为什么能支撑起现实这个复杂的世界？</p>
<p>   UnderStand：</p>
<p>​    不管什么语言写的程序，也不管业务逻辑有多复杂，最终都需要转变成最基本的汇编形式，我们如果将现实世界放在计算机世界的顶层，那么从底层到实际现实需要的便是一层一层的抽象，先通过基本的运算，抽象出变量，抽象出来堆和栈，进而出现高级语言，各种框架，我们需要具备的便是这种层层而上的思想。        </p>
<p>步入正题：第三章第二次笔记</p>
<h3 id="数据传送："><a href="#数据传送：" class="headerlink" title="数据传送："></a>数据传送：</h3><p><img src="https://res.cloudinary.com/shmily/image/upload/v1541926075/assembly.png" alt=""></p>
<p>如图所示，exchange函数由三条指令构成，两个数据传送（movq），一条返回函数被调用点的指令（ret）。</p>
<p>过程开始执行，xp和y分别被存储到寄存器%rdi和%rsi中。第一条movq指令从内存中读出x，并放入%rax中，直接实现了c语言中的x=<em>xp；接着，用寄存器&amp;rax从这个函数返回一个值，因而返回值就是x。下一条指令将y的值写入到寄存器%rdi中的xp指向的内存位置，实现操作 </em>xp=y.该例子说明mov指令从内存中读值到寄存器和从寄存器写入内存。</p>
<p>​    注意：间接引用指针就是将该指针放到一个寄存器中，然后在内存引用中使用这个寄存器，即movq第二条指令</p>
<p>x这种局部变量，通常保存在寄存器中，而不是内存。</p>
<p>​            </p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>

  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/11/06/csapp第二章-信息的处理和表示1/">csapp第二章 信息的处理和表示(1)</a></h1>
  

    <time datetime="2018-11-05T16:26:10.105Z">
  <span class="day">6</span><span class="month">Nov</span>
</time>
  </header>
  <div class="entry-content">
    
      <h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>计算机可寻址的内存单元叫字节，机器级程序将内存视为一个字节数组，称为虚拟内存。内存的每个字节由一个数字标识，该数字就是地址，所有可能地址的集合称为虚拟地址空间，这个虚拟地址空间可视为一个展示给机器级别程序的抽象，即是为程序提供的一个看上去统一的字节数组</p>
<h2 id="字数据大小"><a href="#字数据大小" class="headerlink" title="字数据大小"></a>字数据大小</h2><p>计算机的字长，表明指针数据的标称大小。因为虚拟地址按照这样的一个字来编码，所以字长可以决定虚拟地址空间的最大大小。即w位的机器，虚拟地址范围是0到2的w次方减1</p>
<p>程序一般是向后兼容，即32位机器编译的程序，可以在32位或者64位的机器上运行 如果是在64位机器上编译的程序，就只能在64位机器上运行，我们说32位/64位程序属猴的是程序是被编译的机器类型，而不是其运行的机器类型</p>
<h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><p>对于多字节的程序对象，需要知道对象的地址以及在内存中如何排列地址里面的字节。在几乎所有机器上，多字节的对象都被存储成连续的字节序列，对象的地址是这些字节中最小的地址。</p>
<p>排列一个对象的字节有两种规则。大端法和小端法，选用哪种好没有明确的规定，对于大多数程序员，机器的字节顺序完全不可见，但是由于大小端的存在，字节顺序会成为问题，比如</p>
<ol>
<li>在不同类型机器之间通过网络传输二进制数据，当小端法机器生成的数据被发送到大端法机器上时，接受程序发现字节为反序的。 为了避免这种问题，网络应用程序编写规定发送方将内部转化位网络标准，接受方机器将网络标准转换位它的内部表示。     这里可以抽象出一个思想，当a——&gt;b无法顺利直达时，可以考虑a–&gt;c–&gt;b  如果a–&gt;c  c–&gt;b的花销可以更少，不失为一种很好的选择</li>
<li>检查机器级程序时，阅读会成为一个问题，自然书写的方式和机器里面的字节顺序相反不利于阅读</li>
<li>当编写规避正常的类型系统的程序时，如c语言中的强制类型转换，可以允许一种数据类型引用一个对象，但是这个数据类型和创建这个对象时定义的类型不同。即使这种编码技巧对于系统级编程却是必要的。</li>
</ol>
<p>c中字符串被编码成一个以null（值为0）字符结尾的字符数组</p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>

  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/11/06/csapp第二章-信息的处理和表示2/">csapp第二章 信息的处理和表示(2)</a></h1>
  

    <time datetime="2018-11-05T16:26:10.077Z">
  <span class="day">6</span><span class="month">Nov</span>
</time>
  </header>
  <div class="entry-content">
    
      <h3 id="布尔代数"><a href="#布尔代数" class="headerlink" title="布尔代数"></a>布尔代数</h3><p>弄清楚布尔代数的运算和逻辑运算以及离散数学中的命题逻辑的一一对应关系。</p>
<h3 id="位向量"><a href="#位向量" class="headerlink" title="位向量"></a>位向量</h3><p>固定长度为w，由0和1组成的串</p>
<p>位向量的运算可以对应为参数的每个对应元素的运算</p>
<p>任意a a^a=0</p>
<p>位向量表示有限集合，则布尔运算&amp; 和|对应集合的交并</p>
<h3 id="c语言中的位级运算"><a href="#c语言中的位级运算" class="headerlink" title="c语言中的位级运算"></a>c语言中的位级运算</h3><p>位级运算的常见用法是实现掩码运算，掩码是一个位模式，表示从一个字中选出的位的集合</p>
<p>x&amp;0xFF生成一个由最低有效字节生成的值，其他的字节被置为0</p>
<p>求补时要想到利用异或运算 对1异或可得其补，对0异或可得本身 见p39练习12</p>
<h3 id="c中的逻辑运算"><a href="#c中的逻辑运算" class="headerlink" title="c中的逻辑运算"></a>c中的逻辑运算</h3><p>c中的逻辑运算符||  &amp;&amp;  ！ 对应命题逻辑中的OR AND NOT 注意区分逻辑运算和位级运算</p>
<ol>
<li>第一个区别   逻辑运算所有非0参数都表示为true 参数0才表示false ，按位运算只有在参数被限制为0或1时才和对应的逻辑运算有相同的行为</li>
<li>第二个区别   如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符不会对第二个参数求值</li>
</ol>
<h3 id="c中的移位运算（x-lt-lt-k）-x-gt-gt-k"><a href="#c中的移位运算（x-lt-lt-k）-x-gt-gt-k" class="headerlink" title="c中的移位运算（x&lt;&lt;k）(x&gt;&gt;k)"></a>c中的移位运算（x&lt;&lt;k）(x&gt;&gt;k)</h3><p>左移：向左移动k位，丢弃最高的k位，在右端补k个0</p>
<p>逻辑右移：在左端补k个0，右移k位（无符号数必须逻辑右移）</p>
<p>算术右移：在左端补k个最高有效位的值</p>
<h4 id="java中"><a href="#java中" class="headerlink" title="java中"></a>java中</h4><p>x&gt;&gt;k会将x算术右移k个位置</p>
<p>x&gt;&gt;&gt;k会对x做逻辑右移</p>
<h3 id="整数表示"><a href="#整数表示" class="headerlink" title="整数表示"></a>整数表示</h3><p>书中记述的比较详细，这里仅列出一部分要点</p>
<p>整型数中无符号数的编码，了解函数B2Uw（x的位模式）</p>
<p>补码编码的方式，了解函数B2Tw（x的位模式）</p>
<p>​    补码运算的一些特殊地方，0表示2非负数，所以最高位是1的数会比最高位是0的数多一个 ，也就是负数会比正数多一。</p>
<p>有符号数和无符号数之间的转换：    </p>
<p>​    强制类型转换结果保持位值不变，仅仅改变解释这些位的方式</p>
<p>换句话说，同一个数据，只是解读方式不同 。 补码和无符号数之间的关系，举例16位位模式0xCFC7的补码表示是-12345，无符号表示位53191，而两者绝对值相加得到65536=2的16次方。</p>
<p>补码转换为无符号数，使用函数T2Uw(x)</p>
<p>x&lt;0时，函数值为x+2^w</p>
<p>x&gt;0时，函数值为x</p>
<p>无符号数转换位补码,调用函数U2Tw(u)</p>
<p>u&lt;=TMaxw，函数值为u</p>
<p>u&gt;TMaxw，函数值位u-2^w</p>
<h4 id="扩展一个数字的位表示"><a href="#扩展一个数字的位表示" class="headerlink" title="扩展一个数字的位表示"></a>扩展一个数字的位表示</h4><p>对于一个无符号数转为更大的数据类型只需要简单地在表示的开头添加0，这种运算称为<strong>零扩展</strong></p>
<p>对于有符号的数，即补码进行符号扩展(sign extension)，就是添加最高有效位的值</p>
<h3 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h3><p>无符号加法</p>
<p>x+y<code>=</code>(x+y)<code>mod</code>2^k`</p>
<p>溢出会舍去</p>
<p>阿贝尔群，群论。</p>
<p>补码加法</p>
<p>大多数计算机使用<strong>同样的机器指令</strong>来执行有符号和无符号之和。</p>
<p><img src="http://img.voidcn.com/vcimg/static/loading.png" alt="img"></p>
<p>x（有符号+）y= U2T（T2U（x+y) mod 2^w)</p>
<ul>
<li>先计算x+y</li>
<li>将x+y转换为无符号类型z。</li>
<li>p=z mod 2^w</li>
<li>附.(或者直接对x+y的二进制表示进行截断得到p)</li>
<li><p>将p用有符号类型表示</p>
</li>
<li><p>正溢出，正常，负溢出。</p>
<p><img src="http://img.voidcn.com/vcimg/static/loading.png" alt="img"></p>
</li>
</ul>
<p><img src="http://img.voidcn.com/vcimg/static/loading.png" alt="img"></p>
<p>补码的非</p>
<ul>
<li>因为正负区间的不一致</li>
<li>所以最小的那个负数的相反数<strong>逆元</strong>还是最小的那个负数。</li>
<li>对于任意整数<code>x</code>。<code>-x</code>和<code>~x+1</code>得到的结果完全一样。</li>
</ul>
<p>无符号乘法</p>
<p>只取低w位表示的值，其余截断</p>
<p> 补码乘法</p>
<p>对于无符号和补码乘法，乘法运算的<strong>位级表示</strong>都是一样的，是同一条指令。无符号和补码相乘出来的两个数的低W位 <strong>永远相等</strong>。证明见书。</p>
<p><img src="http://img.voidcn.com/vcimg/static/loading.png" alt="img"></p>
<p> 乘常数</p>
<p>因为乘法速度太慢，机器可能会用（加法，减法，移位）来代替乘法。</p>
<p><img src="http://img.voidcn.com/vcimg/static/loading.png" alt="img"></p>
<p> 除以2的幂</p>
<p>对于无符号类型或整数，直接右移不会有任何问题。</p>
<p>对于负数，最后的值为-48.3，会舍入成 -49，而不是-48.</p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>一个二进制串分为三部分。</p>
<blockquote>
<ol>
<li>符号位，1位，决定正负。</li>
<li>阶码 E，对浮点数加权，2^E。C语言里float，8位；double, 11位。</li>
<li>尾数 M，二进制小数，计算分情况。C里float, 23位；double, 52位。</li>
</ol>
</blockquote>
<p>计算根据阶码分为三种，规格化、非规格化、特殊值，float为例：</p>
<blockquote>
<ol>
<li>规格化，E各位不全为0也不全为1，即e!=0 &amp;&amp; e!=255。E = e - 127。所以E的范围其实是[-126, 127] 。此时 M = m + 1。所以最后绝对值为 M·2^E = (m+1)·2^(e-127)。</li>
<li>非规格化，全为0，e=0。E = 1 - 127. M = m。所以最后绝对值为 M·2^E = m·2^(-126)。当m取最小值2^(-23)时，这也是float能够表示的最小非零数，2^(-149)。</li>
<li>特殊值，全为1，e=255。当m=0时，根据符号位分别得到+∞和-∞。当m!=0时，得到NaN，意为 Not a Number。</li>
</ol>
</blockquote>
<p>至于为什么e=0时，M=m而不是M=m+1？<br>此处结合e=0时，E也不是0-127，而是1-127,正好等于规格化的最小e，也是1-127。这个在非规格化向规格化过渡的时候，相同的指数值，保证整个f的值会随着m的增长而增大（线性的）。因此，对浮点数排序时，也可以像整数一样，直接比较其二进制位，从高位开始比较。</p>
<p>这个设计很有意思，假如在非规格化时，E=0-127，M=1+m，非规格化最大数为E=-127,M=1+(2^23-1)/2^23，f=2^E·M=2^(-126)-2^(-150)。规格化最小数为E=1-127，M=1+0，f’=2^(-126)。（哎？f’&gt;f，额这是哪里算错了吗？）f’-f=2^(-150).</p>
<p>真实情况是，非规格化最大数为E=1-127，M=(2^23-1)/2^23，f=2^(-126)-2^(-149)，规格化最小数仍然是f’=2^(-126).f’-f=2^(-149)。这正是相邻的两个非规格化数的间隔2^(-126)·2^(-23)=2^(-149)。也就是说IEEE的这种设计保持了在非规格化和规格化数之间的一个平滑过渡。 </p>
<p>​    强转与舍入</p>
<ul>
<li>int转为float，不会溢出，但是可能被舍入，毕竟都只有2^32个状态，能表达的总信息量是一定的。如2^24+1和2^24强转为float后，值为2^24.000000。舍入的时候会有一种特殊情况，称为向偶数舍入，在非有效位值正好是两个可能值的中间值时，我们倾向于通过取舍，使得有效位的最后一位为0. </li>
<li>double转float, 可能溢出为-∞或+∞. </li>
<li>float和double转int，向零舍入。如果出现溢出，则值会变成0b1000 0000，也就是-Min。 </li>
</ul>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>

  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/11/06/csapp第一章/">csapp第一章</a></h1>
  

    <time datetime="2018-11-05T16:26:10.045Z">
  <span class="day">6</span><span class="month">Nov</span>
</time>
  </header>
  <div class="entry-content">
    
      <h2 id="收获："><a href="#收获：" class="headerlink" title="收获："></a>收获：</h2><ol>
<li><p>程序的生命周期：</p>
<p>从熟悉的利用ｃ语言编写的hello.c文本文件，经过预处理 编译 汇编 链接阶段生成可执行目标文件 然后保存存储到磁盘上，当在shell里键入./ hello后 shell程序将字符读入寄存器，再存放到内存 敲下回车键 shell知道已经结束输入 加载可执行的hello 程序中的代码和数据从磁盘复制到内存 通过dma省去数据经过处理器的过程  当hello中的代码和数据被加载到内存  处理器开始执行main程序的机器语言指令，这些指令将字符串中的字节从内存复制到寄存器 再复制到显示设备</p>
</li>
<li><p>抽象的使用 </p>
<p>文件是对io的抽象（网络都可以看成是文件）</p>
<p>虚拟内存是对程序存储器的抽象</p>
<p>进程是对正在运行的程序的抽象</p>
<p>虚拟机是对整个计算机的抽象</p>
</li>
</ol>
<p>3.程序的生命周期说明了系统花费大量时间在内存，io和cpu之间复制数据，由此将存储设备划分层次结构</p>
<p>4.并发和并行</p>
<p>使计算机做的更多，运行的更快</p>
<p>并发：指一个同时具有多个活动的系统</p>
<p>并行：用并发来使一个系统运行的更快</p>
<p>理解：并行强调同一时刻发生，并发表示该系统具有执行多个活动的能力，但不是在同一时刻  并发事件不一定要在同一时间发生，并行只同时发生的两个并发事件，具有并发的含义</p>
<p>5文件</p>
<p>文件就是字节序列 每个IO设备，包括磁盘，键盘，显示器，甚至网络都可以看成文件</p>
<p>6进程和线程</p>
<p>操作系统提供的假象：程序独占处理器，内存和io设备 </p>
<p>处理器看上去不断的执行程序中的指令 </p>
<p>处理器并发执行进程，即一个进程的指令和另一个的进程的指令交错执行 </p>
<p>上下文的概念，操作系统保持跟踪程序所需的所有状态信息，这种状态即上下文。操作系统将控制权从一个进程交给另一个进程时，发生上下文转换：保存当前进程上下文，恢复新进程的上下文，控制权交给新进程</p>
<p>进程由多个称为线程的执行单元组成  线程运行在进程的上下文中，共享代码和全局数据</p>
<p>7 虚拟内存</p>
<p>为进程提供的假象：每个进程独占内存，每个进程看到的内存都一样，称为虚拟地址空间</p>
<p>基本思想是把一个进程虚拟内存的内容存储到磁盘上，然后用内存作为磁盘的高速缓冲存</p>
<p>注：上一级的存储器作为低一级的存储器的高速缓存</p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><h4 id="并行必须要多核吗？"><a href="#并行必须要多核吗？" class="headerlink" title="并行必须要多核吗？"></a>并行必须要多核吗？</h4><pre><code>并行需要多核，多个线程**同时**在多个cpu上运行
</code></pre>
    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>

  <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <header>
    
  
    <h1 class="title"><a href="/2018/11/06/记录自己两天的踩坑过程/">记录下Ubuntu的美化和使用</a></h1>
  

    <time datetime="2018-11-05T16:26:10.013Z">
  <span class="day">6</span><span class="month">Nov</span>
</time>
  </header>
  <div class="entry-content">
    
      <p>​    </p>
<p>Ubuntu的配置和美化，话不多说，先上一张图</p>
<p><img src="https://res.cloudinary.com/shmily/image/upload/v1538465988/sys.png" alt="rutu"></p>
<h2 id="配置的话，主要就是几个自己常用软件的安装，包括shadows-qt5，wps，sublime-text，intellij-idea，pycharm，clion，网易云音乐，tim，wechat大部分都可以官网下载安装，少数几个记录下来"><a href="#配置的话，主要就是几个自己常用软件的安装，包括shadows-qt5，wps，sublime-text，intellij-idea，pycharm，clion，网易云音乐，tim，wechat大部分都可以官网下载安装，少数几个记录下来" class="headerlink" title="配置的话，主要就是几个自己常用软件的安装，包括shadows-qt5，wps，sublime text，intellij idea，pycharm，clion，网易云音乐，tim，wechat大部分都可以官网下载安装，少数几个记录下来"></a>配置的话，主要就是几个自己常用软件的安装，包括shadows-qt5，wps，sublime text，intellij idea，pycharm，clion，网易云音乐，tim，wechat大部分都可以官网下载安装，少数几个记录下来</h2><h3 id="bashrc文件配置"><a href="#bashrc文件配置" class="headerlink" title="~/.bashrc文件配置"></a>~/.bashrc文件配置</h3><p>在末尾加上</p>
<p>export JAVA_HOME=/usr/java/jdk-10.0.2<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>
<p>这里主要是配置jdk</p>
<h3 id="etc-profile文件配置"><a href="#etc-profile文件配置" class="headerlink" title="/etc/profile文件配置"></a>/etc/profile文件配置</h3><p>在末尾加上</p>
<p>CATALINA_HOME=//home/dw/apache-tomcat-7.0.91<br>export CATALINA_HOME</p>
<p>这里主要配置tomcat</p>
<h4 id="shadowsocks-qt5"><a href="#shadowsocks-qt5" class="headerlink" title="shadowsocks-qt5"></a>shadowsocks-qt5</h4><p>1 在ubuntu18.04之前的版本下载ss-qt5的步骤是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line"></span><br><span class="line">  	sudo apt-get update</span><br><span class="line"></span><br><span class="line">  	sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure>
<p>2.但是ppa:hzwhuang/ss-qt5 并没有18.04版本的源，所以再执行update会报错。</p>
<p>​    这时，只要编辑/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list 文件，将bionic                       (18.04版本代号)改成xenial（16.04版本代号）。</p>
<p>​    然后再执行</p>
<p>​    sudo apt-get update</p>
<p>​    成功之后就是</p>
<p>​    sudo apt-get install shadowsocks-qt5 </p>
<p>​    完成。</p>
<p>至于在google chrome中配置switch omega可以很容易百度到，这里就不在阐述。</p>
<h4 id="intellij-idea"><a href="#intellij-idea" class="headerlink" title="intellij idea"></a>intellij idea</h4><p>​    主要讲解下破解，ctrl alt t打开终端，vim编辑/etc/hosts 文件 将0.0.0.0 account.jetbrains.com添加入hosts  然后进入 <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a> 获取注册码即可</p>
<h4 id="Apache-tomcat"><a href="#Apache-tomcat" class="headerlink" title="Apache tomcat"></a>Apache tomcat</h4><p>这里我下载的是tomcat 7  </p>
<p>这里有几点要注意的地方，至少在我这台机子上是这样  首先要编辑bin目录下的catalina.sh文件，在文件开头加入</p>
<p>CATALINA_HOME=tomcat目录<br>JAVA_HOME=jdk目录</p>
<p>有可能会在idea出现tomcat权限不够而无法将tomcat集成到项目中这时候就需要</p>
<p>sudo chmod -R 777 tomcat的目录</p>
<h4 id="tim"><a href="#tim" class="headerlink" title="tim"></a>tim</h4><p>这里推荐一片文章，是deepin linux移植过来的wine tim</p>
<p><a href="https://www.lulinux.com/archives/1319" target="_blank" rel="noopener">https://www.lulinux.com/archives/1319</a></p>
<p><strong>1，安装deepin-wine环境：</strong>上<a href="https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu" target="_blank" rel="noopener">https://gitee.com/wszqkzqk/deepin-wine-for-ubuntu</a>页面下载zip包（或用git方式克隆），解压到本地文件夹，在文件夹中打开终端，输入<code>sudo sh ./install.sh</code>一键安装。</p>
<p><strong>2，安装deepin.com应用容器：</strong>在<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/</a>中下载想要的容器，点击deb安装即可。以下为推荐容器:</p>
<ul>
<li>QQ：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im/</a></li>
<li>TIM：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.office/</a></li>
<li>QQ轻聊版：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.qq.im.light/</a></li>
<li>微信：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.wechat/</a></li>
<li>Foxmail：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.foxmail/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.foxmail/</a></li>
<li>百度网盘：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.baidu.pan/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.com.baidu.pan/</a></li>
<li>360压缩：<a href="http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.cn.360.yasuo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/deepin/pool/non-free/d/deepin.cn.360.yasuo/</a></li>
</ul>
<p><strong>3，Ubuntu 18.04 Gnome桌面显示传统托盘图标：</strong>安装TopIconPlus的gnome-shell扩展，命令：<code>sudo apt-get install gnome-shell-extension-top-icons-plus gnome-tweaks</code>，然后用gnome-tweaks开启这个扩展。</p>
<p>关于这个第三步讲解一下，gnome是18.04的桌面环境 如果需要美化则需要gnome-tweak-tool这个工具，可以apt install安装，但是里面的拓展很少，我把我电脑里的拓展截图下来</p>
<p><img src="https://res.cloudinary.com/shmily/image/upload/v1538468221/sys2.png" alt="image"></p>
<p>当你安装好tweak tool，再安装上述第三个工具会出现很多拓展，至于每个拓展有什么用，自己去试吧</p>
<p>上述有一个dash to dock的可以这样安装</p>
<p>​    1 安装git： sudo apt-get install git </p>
<p>​    2 sudo git clone <a href="https://github.com/micheleg/dash-to-dock.git">https://github.com/micheleg/dash-to-dock.git</a></p>
<p>​    3 cd dash to dock</p>
<p>​    4 sudo make </p>
<p>​    5 make install</p>
<p>因为git下来的是源代码，你需要手动make才可以使用，上述完成之后，alt+f2 输入r 重启桌面 ，打开tweak tool即可</p>
<p>电脑右上角有个显示网速的工具叫系统负载查看器 软件商店里有    安装后自己配置</p>
<p>首选项中全不勾选</p>
<p>indicator items把网速置顶即可    </p>
<h4 id="flameshot"><a href="#flameshot" class="headerlink" title="flameshot"></a>flameshot</h4><p>Ubuntu上还有个好用的截图工具flameshot   具体这样配置</p>
<p> <strong>sudo apt-get install flameshot</strong></p>
<p>进入 设置&gt;设备&gt;键盘，拉到最下面，点击加号</p>
<p>快捷键命令填写：<strong>flameshot gui</strong></p>
<p>暂时更新到这里</p>
<p>​    </p>

    
    
    <footer class="meta">
      
      
      
    </footer>
    
  </div>
  
</article>


<nav id="pagenavi">
  
  
  <div class="clearfix"></div>
</nav></div>
  <footer id="footer" class="inner"><div class="social alignright">
  
  
  
  
  <a class="rss" href="/atom.xml" title="RSS">RSS</a>
</div>
<p>
  
  &copy; 2018 dw Shao
  
</p>
<div class="clearfix"></div></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id="phasebeam">
  <canvas></canvas>
  <canvas></canvas>
  <canvas></canvas>
</div>
<script src="/js/phasebeam.js"></script>
</body>
</html>